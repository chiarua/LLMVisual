"use strict";
var chai_1 = require("chai");
var TJS = require("../typescript-json-schema");
var fs_1 = require("fs");
var path_1 = require("path");
var Ajv = require("ajv");
var ajv = new Ajv();
var base = "test/programs/";
function assertSchema(group, name, type, settings, compilerOptions) {
    if (settings === void 0) { settings = {}; }
    it(group + " should create correct schema", function () {
        if (!("generateRequired" in settings)) {
            settings.generateRequired = true;
        }
        var actual = TJS.generateSchema(TJS.getProgramFromFiles([path_1.resolve(base + group + "/" + name)], compilerOptions), type, settings);
        var file = fs_1.readFileSync(base + group + "/schema.json", "utf8");
        var expected = JSON.parse(file);
        chai_1.assert.isObject(actual);
        chai_1.assert.deepEqual(actual, expected, "The schema is not as expected");
        if (actual !== null) {
            ajv.validateSchema(actual);
            chai_1.assert.equal(ajv.errors, null, "The schema is not valid");
        }
    });
}
exports.assertSchema = assertSchema;
describe("interfaces", function () {
    it("should return an instance of JsonSchemaGenerator", function () {
        var program = TJS.getProgramFromFiles([path_1.resolve(base + "comments/main.ts")]);
        var generator = TJS.buildGenerator(program);
        chai_1.assert.instanceOf(generator, TJS.JsonSchemaGenerator);
        if (generator !== null) {
            chai_1.assert.doesNotThrow(function () { return generator.getSchemaForSymbol("MyObject"); });
            chai_1.assert.doesNotThrow(function () { return generator.getSchemaForSymbol("Vector3D"); });
            var symbols = generator.getUserSymbols();
            chai_1.assert(symbols.indexOf("MyObject") > -1);
            chai_1.assert(symbols.indexOf("Vector3D") > -1);
        }
    });
    it("should output the schemas set by setSchemaOverride", function () {
        var program = TJS.getProgramFromFiles([path_1.resolve(base + "interface-multi/main.ts")]);
        var generator = TJS.buildGenerator(program);
        chai_1.assert(generator !== null);
        if (generator !== null) {
            var schemaOverride = { type: "string" };
            generator.setSchemaOverride("MySubObject", schemaOverride);
            var schema = generator.getSchemaForSymbol("MyObject");
            chai_1.assert.deepEqual(schema.definitions["MySubObject"], schemaOverride);
        }
    });
});
describe("schema", function () {
    assertSchema("array-and-description", "main.ts", "MyObject");
    assertSchema("class-single", "main.ts", "MyObject");
    assertSchema("interface-single", "main.ts", "MyObject");
    assertSchema("interface-multi", "main.ts", "MyObject");
    assertSchema("interface-recursion", "main.ts", "MyObject", {
        useRootRef: true
    });
    assertSchema("module-interface-single", "main.ts", "MyObject");
    assertSchema("enums-string", "main.ts", "MyObject");
    assertSchema("enums-number", "main.ts", "MyObject");
    assertSchema("enums-number-initialized", "main.ts", "Enum");
    assertSchema("enums-compiled-compute", "main.ts", "Enum");
    assertSchema("enums-mixed", "main.ts", "MyObject");
    assertSchema("string-literals", "main.ts", "MyObject");
    assertSchema("string-literals-inline", "main.ts", "MyObject");
    assertSchema("array-readonly", "main.ts", "MyReadOnlyArray");
    assertSchema("array-types", "main.ts", "MyArray");
    assertSchema("map-types", "main.ts", "MyObject");
    assertSchema("namespace", "main.ts", "Type");
    assertSchema("type-anonymous", "main.ts", "MyObject");
    assertSchema("type-primitives", "main.ts", "MyObject");
    assertSchema("type-nullable", "main.ts", "MyObject");
    assertSchema("optionals", "main.ts", "MyObject");
    assertSchema("comments", "main.ts", "MyObject");
    assertSchema("comments-override", "main.ts", "MyObject");
    assertSchema("force-type", "main.ts", "MyObject");
    assertSchema("force-type-imported", "main.ts", "MyObject");
    assertSchema("type-alias-single", "main.ts", "MyString");
    assertSchema("type-aliases", "main.ts", "MyObject", {
        useTypeAliasRef: true
    });
    assertSchema("type-aliases-fixed-size-array", "main.ts", "MyFixedSizeArray");
    assertSchema("type-aliases-multitype-array", "main.ts", "MyArray");
    assertSchema("type-aliases-local-namsepace", "main.ts", "MyObject", {
        useTypeAliasRef: true
    });
    assertSchema("type-aliases-alias-ref", "main.ts", "MyAlias", {
        useTypeAliasRef: true,
        useRootRef: false
    });
    assertSchema("type-aliases-recursive-object-topref", "main.ts", "MyObject", {
        useTypeAliasRef: true,
        useRootRef: true
    });
    assertSchema("type-no-aliases-recursive-topref", "main.ts", "MyAlias", {
        useTypeAliasRef: false,
        useRootRef: true
    });
    assertSchema("type-union", "main.ts", "MyObject");
    assertSchema("type-intersection", "main.ts", "MyObject");
    assertSchema("type-union-tagged", "main.ts", "Shape");
    assertSchema("type-aliases-union-namespace", "main.ts", "MyModel");
    assertSchema("strict-null-checks", "main.ts", "MyObject", undefined, {
        strictNullChecks: true
    });
    assertSchema("annotation-default", "main.ts", "MyObject");
});
//# sourceMappingURL=schema.test.js.map